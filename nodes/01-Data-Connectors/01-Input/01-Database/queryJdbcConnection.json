{
  "id": "11",
  "name": "Query JDBC",

  "description": "This node executes query on Relational Databases using JDBC and creates a DataFrame from it",
  "input": "It reads data from Relational Databases",
  "output": "It creates a DataFrame from the data read and sends it to its output",

  "type": "dataset",
  "nodeClass": "fire.nodes.dataset.NodeJDBCQueryUsingConnection",
  "fields" : [
    {"name":"connection", "value":"", "widget": "object_array", "title": "Connection", "description": "The JDBC connection to connect" ,"required":"true"},
    {"name":"query", "value":"", "widget": "textarea_small", "title": "Query", "required":"true", "description": ""},

    {"name": "schema", "value":"", "widget": "tab", "title": "Schema"},
    {"name":"outputColNames", "value":"[]", "widget": "schema_col_names", "title": "Column Names of the Table", "description": "Output Columns Names of the Table"},
    {"name":"outputColTypes", "value":"[]", "widget": "schema_col_types", "title": "Column Types of the Table", "description": "Output Column Types of the Table"},
    {"name":"outputColFormats", "value":"[]", "widget": "schema_col_formats", "title": "Column Formats", "description": "Output Column Formats"}
  ,
    {"name": "properties", "value":"", "widget": "tab", "title": "Properties"},
    {"name":"pushDownPredicate", "value":"true", "widget": "array", "title": "Push Down Predicate", "optionsArray": ["true","false"], "description": "Enable or disable predicate push-down into the JDBC data source. The default value is true, in which case Spark will push down filters to the JDBC data source as much as possible. " },
    {"name":"pushDownAggregate", "value":"false", "widget": "array", "title": "Push Down Aggregate", "optionsArray": ["true","false"], "description": "Enable or disable aggregate push-down in V2 JDBC data source. The default value is false, in which case Spark will not push down aggregates to the JDBC data source. Aggregate push-down is usually turned off when the aggregate is performed faster by Spark than by the JDBC data source. Please note that aggregates can be pushed down if and only if all the aggregate functions and the related filters can be pushed down." },
    {"name":"fetchsize", "value":"", "widget": "textfield", "title": "Fetch Size", "description": "The JDBC fetch size, which determines how many rows to fetch per round trip. This can help performance on JDBC drivers which default to low fetch size (e.g. Oracle with 10 rows)." },
    {"name":"queryTimeout", "value":"", "widget": "textfield", "title": "Query Timeout", "description": "The number of seconds the driver will wait for a Statement object to execute. Zero means there is no limit." },
    {"name":"sessionInitStatement", "value":"", "widget": "textfield", "title": "Session Init Statement", "description": "After each database session is opened to the remote DB and before starting to read data, this parameter executes a custom SQL statement (or a PL/SQL block). Use this to implement session initialization code. Example: option(\"sessionInitStatement\", \"BEGIN execute immediate 'alter session set \"_serial_direct_read\"=true'; END;\").", "expandable": true},


    {"name": "performance", "value":"", "widget": "tab", "title": "Performance"},

    {"name":"partitionColumn", "value":"", "widget": "textfield", "title": "Partition Column", "description": "PartitionColumn must be a numeric, date, or timestamp column from the table" },
    {"name":"lowerBound", "value":"", "widget": "textfield", "title": "Lower Bound", "description": " LowerBound and UpperBound are just used to decide the partition stride, not for filtering the rows in the table. All rows in the table will be partitioned and returned. This option applies only to reading" },
    {"name":"upperBound", "value":"", "widget": "textfield", "title": "Upper Bound", "description": " LowerBound and UpperBound are just used to decide the partition stride, not for filtering the rows in the table. All rows in the table will be partitioned and returned. This option applies only to reading" },
    {"name":"numPartitions", "value":"", "widget": "textfield", "title": "Num Partitions", "description": "The maximum number of partitions that can be used for parallelism in table reading" }


  ]
}
start-details:

h2: Query JDBC Node Details

This node executes query on Relational Databases using JDBC and creates a DataFrame from it.

h4: Parameters to be set:
* OUTPUT STORAGE LEVEL : Keep this as DEFAULT.
* CONNECTION : Select the desired connection to be used.
* QUERY : Specify the SQL query to execute to retrieve data from the database.
* SCHEMA COLUMNS : Refresh the schema for loading column name,column type,column format. 

end-details:

start-examples:

h2: Query JDBC Node Examples

h4: Example of Connection Values
* CONNECTION : JDBC_Connection
* QUERY : SELECT * FROM customers WHERE country = 'USA'
* SCHEMA COLUMNS : Refresh the schema for loading column name,column type,column format.

end-examples:
