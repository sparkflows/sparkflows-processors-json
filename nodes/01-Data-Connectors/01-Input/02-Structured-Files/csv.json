{
  "id": "11",
  "name": "Read CSV",
  "iconImage": "/images/icons/node-icon/csv.svg",

  "description": "It reads in CSV files and creates a DataFrame from it.",
  "input": "It reads in CSV text files",
  "output": "It creates a DataFrame from the data read and sends it to its output",
  "hint": "Refresh the schema when a new file is selected or the file content has changed",
  "type": "dataset",
  "engine": "all",
  "nodeClass": "fire.nodes.dataset.NodeDatasetCSV",
  "fields" : [
    {"name":"path", "display":true,"value":"", "widget": "textfield", "required":true, "title": "Path", "description": "Path of the file/directory"},
    {"name":"separator", "value":",", "widget": "textfield", "title": "Separator", "description": "CSV Separator"},
    {"name": "header", "value":"true", "widget": "array", "title": "Header", "optionsArray": ["true","false"],
            "description": "Whether the file has a header row"},
    {"name": "dropSpecialCharacterInColumnName", "value":"false", "widget": "array", "title": "Drop Special Character In ColumnName", "optionsArray": ["true","false"],
      "description": "Whether to drop the Special Characters and Spaces in Column Name."},
    {"name": "mode", "value":"PERMISSIVE", "widget": "array", "title": "Mode", "optionsArray": ["PERMISSIVE","DROPMALFORMED","FAILFAST"],
      "description": "Mode for dealing with corrupt records during parsing."},
    {"name": "enforceSchema", "value":"false", "widget": "array", "title": "Enforce Schema", "optionsArray": ["false","true"],
      "description": "If it is set to true, the specified or inferred schema will be forcibly applied to datasource files, and headers in CSV files will be ignored. If the option is set to false, the schema will be validated against all headers in CSV files in the case when the header option is set to true."},
    {"name": "addInputFileName", "value":"false", "widget": "array", "title": "Whether to Add Input File Name as Column in the Dataframe", "optionsArray": ["false","true"],
      "description": "Add the new field:input_file_name"},
    {"name": "encoding", "value":"UTF-8", "widget": "textfield", "title": "Encoding", "description": "Decodes the CSV files by the given encoding type"},
    {"name":"quote", "value":"\"", "widget": "textfield", "title": "Quote", "description": "Sets a single character used for escaping quoted values where the separator can be part of the value"},
    {"name":"escape", "value":"\\", "widget": "textfield", "title": "Escape", "description": "Sets a single character used for escaping quotes inside an already quoted value."},

    {"name": "schema", "value": "", "widget": "tab", "title": "Schema"},
    {"name":"outputColNames", "value":"[]", "widget": "schema_col_names", "title": "Column Names for the CSV", "description": "New Output Columns of the SQL"},
    {"name":"outputColTypes", "value":"[]", "widget": "schema_col_types", "title": "Column Types for the CSV", "description": "Data Type of the Output Columns"},
    {"name":"outputColFormats", "value":"[]", "widget": "schema_col_formats", "title": "Column Formats for the CSV", "description": "Format of the Output Columns"},

    {"name": "extraOptions", "value": "", "widget": "tab", "title": "Extra Options"},
    {"name": "extraOptionsKeys", "value":"[]", "widget": "key_array", "title": "Extra Options Keys", "header":"Extra Options", "description": "Extra options available when reading CSV files. Examples :\n comment --> # (ignore comment lines in the file)\nignoreLeadingWhiteSpace --> false (Ignores leading white spaces in string columns)\nignoreTrailingWhiteSpace --> false (Ignores trailing white spaces in string columns).\nfilterPushdown --> true (Enables filter pushdown to optimize query performance.)\nsamplingRatio --> 1.0 (Specifies the ratio of rows to sample when inferring schema.)\nignoreCorruptFiles --> false (Skips files with corrupt data instead of failing.)\nignoreMissingFiles --> false (Skips missing files instead of failing.)\npathGlobFilter --> *.csv (Filters file paths based on a specified glob pattern.)\nrecursiveFileLookup --> false (Enables recursive file lookup in directories.)"},
    {"name": "extraOptionsValues", "value":"[]", "widget": "value_array", "title": "Extra Options Values", "description": "Config Values for the Corresponding keys"}

  ]
}
start-details:

h2:Read CSV Details

This node reads CSV files and creates a DataFrame from them. It can read either a single file or a directory containing multiple files. The user can configure the below fields to parse the file.

The user can choose the <b>Output storage level</b> from the drop down. The options in the dropdown can be one of the following:
* <b>MEMORY_ONLY</b>          Store RDD as deserialized Java objects in the JVM. If the RDD does not fit in memory, some partitions will not be cached and will be recomputed on the fly each time they are needed. This is the default level.
* <b>MEMORY_AND_DISK</b>       Store RDD as deserialized Java objects in the JVM. If the RDD does not fit in memory, store the partitions that do not fit on disk, and read them from there when they are needed.
* <b>MEMORY_ONLY_SER</b>        Store RDD as serialized Java objects (one byte array per partition). This is generally more space-efficient than deserialized objects, especially when using a fast serializer, but more CPU-intensive to read.
* <b>MEMORY_AND_DISK_SER</b>    Similar to MEMORY_ONLY_SER, but spill partitions that do not fit in memory to disk instead of recomputing them on the fly each time they're needed.
* <b>DISK_ONLY</b>              Store the RDD partitions only on disk.
* <b>MEMORY_ONLY_2, MEMORY_AND_DISK_2 others </b> . Same as the levels above, but replicate each partition on two cluster nodes.
* <b>OFF_HEAP</b>               Similar to MEMORY_ONLY_SER, but store the data in off-heap memory. This requires off-heap memory to be enabled.

The user needs to provide a data file <b>Path</b> to read the data from. This is a required field.

The user can choose the <b>Separator</b> used in the data file to parse it. The default separator is <b>( , )</b> comma.

In the <b>Header</b> field, one can choose:
* <b>true</b> if the data file has a header.
* <b>false</b> Otherwise.

In the <b>Drop special character in column name</b> field, one can choose:
* <b>true</b> If you want to remove the special characters from column names.
* <b>false</b> Otherwise.

In the <b>Mode</b> field, one can choose from the below options in the dropdown:
* <b>PERMISSIVE</b> When the parser meets a corrupt field in a record, it sets the value of the field to NULL and continues to the next record.
* <b>DROPMALFORMED</b> ignores the whole corrupted record.
* <b>FAILFAST</b> throws an exception when it meets corrupted records.

In the <b>Enforce Schema</b> field, one can choose:
* <b>true</b> The specified or inferred schema will be forcibly applied to datasource files, and headers in CSV files will be ignored.
* <b>false</b> The schema will be validated against all headers in CSV files when the header option is set to <b>false</b>.

In the <b>Whether to add input file as a column in DataFrame</b> field, one can choose:
* <b>true</b> There will be a new column added to the DataFrame at the end, which can be seen in the schema columns. One can enter the name of this column.
* <b>false</b> This functionality is disabled, and the DataFrame consists of only the columns read from the data file.

In the <b>ENCODING</b> field, one can specify the encoding type to be used for reading the files. By default, it is set as <b>UTF-8</b>.

The <b>QUOTE</b> field sets a single character used for escaping quoted values where the separator can be part of the value. The default value for this is <b>( " )</b>, a double quote.

The <b>ESCAPE</b> field sets a single character used for escaping quotes inside an already quoted value. The default value for this is <b>( \ )</b>, a backslash.	

After the above options are set, one can click on <b>Refresh Schema</b> to see the final columns.
Users can still add or delete columns using <b>+</b> button next to the refresh schema and <b>-</b> button next to the column names.

end-details:

start-examples:

h2: Read CSV Node Example

Given a CSV file with the following data:

SupplierID,SupplierName,Region,YearsInBusiness,LeadTime,PriceIndex,OrderFulfillmentTime,OverallCost,OrderCancellations,CustomerRating
S1,Supplier A,Region 1,10,5,1.2,3,100,2,4
S2,Supplier B,Region 2,15,7,1.1,4,120,1,5
If you configure the Read CSV node as follows:

Path: /path/to/your/file.csv
Separator: ,
Header: true
The output would be a DataFrame with the following schema:

Column Name	Data Type
SupplierID	String
SupplierName	String
Region	String
YearsInBusiness	Integer
LeadTime	Integer
PriceIndex	Double
OrderFulfillmentTime	Integer
OverallCost	Integer
OrderCancellations	Integer
CustomerRating	Integer

end-examples:
