{
  "id": "6",
  "name": "Group By",
  "description": "Group By Node",
  "type": "transform",
  "engine": "all",
  "nodeClass": "fire.nodes.etl.NodeGroupBy",
  "fields" : [

    {"name": "Aggregation Setting", "value":"", "widget": "tab", "title": "Aggregation Setting"},

    {"name": "groupingCols", "value":"[]", "widget": "variables", "title": "Grouping Columns", "description": "Grouping Columns",
      "required": true},

    {"name": "aggregateCols", "value":"[]", "widget": "variables_list_select", "title": "Aggregate Columns","header":"Aggregate", "description": "Aggregate Columns","required": true},
    {"name": "aggregateOperations", "value":"[]", "widget": "variables_list_array",
            "optionsArray": ["sum", "avg", "min", "max", "count", "count_distinct"], "title": "Aggregate Operation", "description": "Aggregate Operation", "required": true},
    {"name": "outputColNames", "value":"[]", "widget": "variables_list_textfield", "title": "Output Column Names", "description": "Output Column Names, default value is aggregateOperation_aggregateCol."},

    {"name": "Filter Setting", "value":"", "widget": "tab", "title": "Filter Setting"},

    {"name":"whereClause", "value":"", "widget": "textarea_small", "title": "Where Clause", "description": "where condition before group by function"},

    {"name":"havingClause", "value":"", "widget": "textarea_small", "title": "Having Clause", "description": "having condition after group by function"}
  ]
}

start-details:

h2:Group By Details

h3:Aggregation Settings
This node groups row values based on categorical columns selected by the user and then calculates aggregate statistics of the grouped columns. 
The Grouping Columns allows the user to select which columns to group rows by, and the Variables List allows the user to select which aggregate statistics will be generated. 

h3:Filter Settings
The Filter Settings allow the user to provide additional clauses before and after the data is aggregated.
The Where Clause allows the user to filter the data before it is aggregated, and the Having Clause allows the user to filter the data after it has been aggregated. 
Both the Where and Having Clauses are similar in use to those that exist in many forms of SQL. 

end-details:

start-examples:

Incoming Dataframe has following rows:

EMP_CD    |    EMP_NAME    |    LOCATION    |    DEPT         |    SALARY
-----------------------------------------------------------------------------
E01       |    DAVID       |    NEW YORK    |    HR           |    10000
E02       |    JOHN        |    NEW JERSEY  |    SALES        |    11000
E03       |    MARTIN      |    NEW YORK    |    MARKETING    |    12000
E04       |    TONY        |    NEW JERSEY  |    MARKETING    |    13000
E05       |    ROSS        |    NEW YORK    |    FRONT DESK   |    10000
E06       |    LISA        |    NEW JERSEY  |    FRONT DESK   |    11000
E07       |    PAUL        |    NEW YORK    |    MAINTENANCE  |    12000
E08       |    MARK        |    NEW JERSEY  |    MAINTENANCE  |    13000

if GroupBy node is configured as below:

GROUPING COLUMNS      :    DEPT

AGGREGATE COLUMNS    |    AGGREGATE OPERATION
-------------------------------------------------
EMP_CD               |    COUNT
SALARY               |    SUM

then outgoing Dataframe would be created as below after performing specified aggregation
Count of Employees and Summation of Salary all Employees is computed for each [DEPT]:

DEPT           |    count_emp_cd    |    sum_salary
----------------------------------------------------------
FRONT DESK     |    2               |    21000
MARKETING      |    2               |    25000
HR             |    1               |    10000
SALES          |    1               |    11000
MAINTENANCE    |    2               |    25000

if [WHERE CLAUSE] is entered as [DEPT = 'HR'] then outgoing Dataframe would consists of data only from HR department.

if [HAVING CLAUSE] is entered as [COUNT(*) > 1] then outgoing Dataframe would consists of data for Department where count of Employees is more than 1.

end-examples:
