{
  "id": "21",
  "name": "H2O Neural Network",
  "description": "H2O Deep Learning is based on a multi-layer feedforward artificial neural network that is trained with stochastic gradient descent using back-propagation.",
  "input": "It takes in a DataFrame as input",
  "output": "",
  "type": "ml-estimator",
  "nodeClass": "fire.nodes.h2o.NodeH2ONeuralNetwork",
  "fields" : [
    {"name": "isResponseIsCategorical", "value":"false", "widget": "array","optionsArray": ["false","true"], "title": "isResponseColIsCategorical", "description": "Specify a response column type(numeric or categorical). Separates the Classification and Regression"},
    {"name": "labelCol", "value":"label", "required":"true", "widget": "variable", "title": "Label Column", "description": "Response variable column."},
    {"name": "ignoredCols", "value":"[]", "widget": "variables", "title": "Ignored Columns", "description": "Features to be ignored for Modelling"},
    {"name": "splitRatio", "value":1.0, "widget": "textfield", "title": "Split Ratio", "description": "Split Ratio", "datatypes":["float"]},

    {"name": "columnsToCategorical", "value":"[]", "widget": "variables", "title": "Columns to Categorical", "description": "Columns to be Categorical encoded"},
    {"name": "seed", "value":"-1", "widget": "textfield", "title": "Seed", "description": "Seed for pseudo random number generator (if applicable).", "datatypes":["Long"]},
    {"name": "balanceClasses", "value":"false", "widget": "textfield", "title": "Balance Classes", "description": "Balance training data class counts via over/under-sampling (for imbalanced data).", "datatypes":["boolean"]},
    {"name": "maxAfterBalanceSize", "value":"5.0", "widget": "textfield", "title": "Max After Balance Size", "description": "Maximum relative size of the training data after balancing class counts (can be less than 1.0). Requires balance_classes.", "datatypes":["double"]},
    {"name": "activation", "value":"Rectifier","widget": "array", "title": "Activation", "optionsArray": ["Rectifier","Tanh", "TanhWithDropout", "RectifierWithDropout", "Maxout","MaxoutWithDropout", "ExpRectifier", "ExpRectifierWithDropout" ], "description": "Activation function."},
    {"name": "hidden", "value":"200,200", "widget": "textfield", "title": "Hidden", "description": "Specify the hidden layer sizes (value must be positive)"},
    {"name": "epochs", "value":"10.0", "widget": "textfield", "title": "Epochs", "description": "SHow many times the dataset should be iterated (streamed), can be fractional.", "datatypes":["double"]},
    {"name": "nfolds", "value":"0", "widget": "textfield", "title": "Number of Folds", "description": "Number of folds for K-fold cross-validation (0 to disable or >= 2).", "datatypes":["integer"]},
    {"name": "trainSamplesPerIteration", "value":"-2", "widget": "textfield", "title": "Train Samples Per Iteration", "description": "Number of training samples (globally) per MapReduce iteration. Special values are 0: one epoch, -1: all available data (e.g., replicated training data), -2: automatic.", "datatypes":["Long"]},
    {"name": "targetRatioCommToComp", "value":"0.05", "widget": "textfield", "title": "Target ratio comm to comp", "description": "Target ratio of communication overhead to computation. Only for multi-node operation and train_samples_per_iteration = -2 (auto-tuning).", "datatypes":["double"]},
    {"name": "categoricalEncoding", "value":"AUTO", "widget": "array", "title": "Categorical Encoding", "optionsArray": ["AUTO","OneHotInternal", "OneHotExplicit", "Enum"," Binary", "Eigen", "LabelEncode", "SortByResponse", "EnumLimited"], "description": "Specify one of the various encoding schemes for handling categorical features" ,"datatypes":["string"]},
    {"name": "ignoreConstCols", "value":"true", "widget": "array", "title": "Ignore Const Columns", "optionsArray": ["false","true"], "description": "Ignore constant columns." ,"datatypes":["boolean"]},
    {"name": "scoreEachIteration", "value":"false", "widget": "array", "title": "Score Each Iteration", "optionsArray": ["false","true"], "description": "Whether to score during each iteration of model training." ,"datatypes":["boolean"]},
    {"name": "stoppingRounds", "value":"0", "widget": "textfield", "title": "Stopping Rounds", "description": "Early stopping based on convergence of stopping_metric. Stop if simple moving average of length k of the stopping_metric does not improve for k:=stopping_rounds scoring events (0 to disable).", "datatypes":["integer"]},
    {"name": "maxRuntimeSecs","value":"0.0", "widget": "textfield", "title": "Max Runtime Secs", "description": "his argument specifies the maximum time that the AutoML process will run for. If both max_runtime_secs and max_models are specified, then the AutoML run will stop as soon as it hits either of these limits. If neither max_runtime_secs nor max_models are specified, then max_runtime_secs defaults to 3600 seconds (1 hour).", "datatypes":["double"]},
    {"name": "stoppingMetric", "value":"AUTO", "widget": "array","optionsArray": ["AUTO","deviance","logloss","MSE", "RMSE", "MAE", "RMSLE", "AUC", "AUCPR","lift_top_group", "misclassification", "mean_per_class_error", "anomaly_score", "custom","custom_increasing"], "title": "StoppingMetric", "description": "Metric to use for early stopping (AUTO: logloss for classification, deviance for regression)"},
    {"name": "stoppingTolerance", "value":"0.001", "widget": "textfield", "title": "StoppingTolerance", "description": "Relative tolerance for metric-based stopping criterion (stop if relative improvement is not at least this much)", "datatypes":["double"]},
    {"name": "standardize", "value":"true", "widget": "array","optionsArray": ["false","true"], "title": "Standardize", "description": "If enabled, automatically standardize the data. If disabled, the user must provide properly scaled input data.", "datatypes":["boolean"]},
    {"name": "loss", "value":"Automatic", "widget": "array", "title": "Loss", "optionsArray": ["Automatic","Quadratic", "CrossEntropy", "ModifiedHuber", "Huber", "Absolute", "Quantile"],"description": "SLoss function."},
    {"name": "adaptiveRate", "value":"true", "widget": "array","optionsArray": ["false","true"], "title": "Adaptive Rate", "description": "Adaptive learning rate.", "datatypes":["boolean"]},
    {"name": "rho", "value":"0.99", "widget": "textfield", "title": "Rho", "description": "Adaptive learning rate time decay factor (similarity to prior updates).", "datatypes":["double"]},

    {"name": "advanced", "value":"", "widget": "tab", "title": "Advanced"},
    {"name": "epsilon", "value":"1e-8", "widget": "textfield", "title": "Epsilon", "description": "Adaptive learning rate smoothing factor (to avoid divisions by zero and allow progress).", "datatypes":["double"]},
    {"name": "rate", "value":"0.005", "widget": "textfield", "title": "Rate", "description": "Learning rate (higher => less stable, lower => slower convergence).", "datatypes":["double"]},
    {"name": "rateAnnealing", "value":"1e-6", "widget": "textfield", "title": "Rate Annealing", "description": "Learning rate annealing: rate / (1 + rate_annealing * samples).", "datatypes":["double"]},
    {"name": "rateDecay", "value":"1.0", "widget": "textfield", "title": "Rate Decay", "description": "Learning rate decay factor between layers (N-th layer: rate * rate_decay ^ (n - 1)", "datatypes":["double"]},
    {"name": "momentumStart", "value":"0.0", "widget": "textfield", "title": "Momentum Start", "description": "Specify the initial momentum at the beginning of training; we suggest 0.5 (Applicable only if adaptive_rate is disabled)", "datatypes":["double"]},
    {"name": "momentumRamp", "value":"1000000.0", "widget": "textfield", "title": "Momentum Ramp", "description": "Number of training samples for which momentum increases.", "datatypes":["double"]},
    {"name": "momentumStable", "value":"0", "widget": "textfield", "title": "Momentum Stable", "description": "Final momentum after the ramp is over (try 0.99).", "datatypes":["double"]},
    {"name": "nesterovAcceleratedGradient", "value":"true", "widget": "textfield", "title": "Nesterov Accelerated Gradient", "description": "Use Nesterov accelerated gradient (recommended).", "datatypes":["boolean"]},
    {"name": "inputDropoutRatio", "value":"0.0", "widget": "textfield", "title": "Input Dropout Ratio", "description": "Input layer dropout ratio (can improve generalization, try 0.1 or 0.2).", "datatypes":["double"]},
    {"name": "inputDropoutRatio", "value":"", "widget": "textfield", "title": "Hidden Dropout Ratios", "description": "Hidden layer dropout ratios (can improve generalization), specify one value per hidden layer, defaults to 0.5."},
    {"name": "l1", "value":"0.0", "widget": "textfield", "title": "L1", "description": "L1 regularization (can add stability and improve generalization, causes many weights to become 0).", "datatypes":["double"]},
    {"name": "l2", "value":"0.0", "widget": "textfield", "title": "L2", "description": "L2 regularization (can add stability and improve generalization, causes many weights to be small.", "datatypes":["double"]},
    {"name": "maxW2", "value":"3.402823e38", "widget": "textfield", "title": "Max W2", "description": "Constraint for squared sum of incoming weights per unit (e.g. for Rectifier).", "datatypes":["double"]},
    {"name": "initialWeightDistribution", "value":"UniformAdaptive", "widget": "array", "title": "Initial Weight Distribution", "optionsArray": ["UniformAdaptive","Uniform","Normal"],"description": "Initial weight distribution.", "datatypes":["string"]},
    {"name": "initialWeightScale", "value":"1.0", "widget": "textfield", "title": "Initial Weight Scale", "description": "Uniform: -value...value, Normal: stddev.", "datatypes":["double"]},
    {"name": "scoreInterval", "value":"5.0", "widget": "textfield", "title": "Score interval", "description": "Shortest time interval (in seconds) between model scoring.", "datatypes":["double"]},
    {"name": "scoreTrainingSamples", "value":"10000", "widget": "textfield", "title": "Score Training Samples", "description": "Number of training set samples for scoring (0 for all).", "datatypes":["Long"]},
    {"name": "scoreValidationSamples", "value":"0", "widget": "textfield", "title": "Score Validation Samples", "description": "Number of validation set samples for scoring (0 for all).", "datatypes":["Long"]},
    {"name": "scoreDutyCycle", "value":"0.1", "widget": "textfield", "title": "Score Duty Cycle", "description": "Maximum duty cycle fraction for scoring (lower: more training, higher: more scoring).", "datatypes":["double"]},
    {"name": "classificationStop", "value":"0", "widget": "textfield", "title": "Classification Stop", "description": "Stopping criterion for classification error fraction on training data (-1 to disable).", "datatypes":["double"]},
    {"name": "regressionStop", "value":"1e-6", "widget": "textfield", "title": "Regression Stop", "description": "Stopping criterion for regression error (MSE) on training data (-1 to disable).", "datatypes":["double"]},
    {"name": "quietMode", "value":"false", "widget": "array", "title": "Quiet mode", "optionsArray": ["false","true"], "description": "Enable quiet mode for less output to standard output.", "datatypes":["boolean"]},
    {"name": "scoreValidationSampling", "value":"Uniform", "widget": "array", "optionsArray": ["Stratified","Uniform"], "title": "Score Validation Sampling", "description": "Method used to sample validation dataset for scoring."},
    {"name": "overwriteWithBestModel", "value":"true", "widget": "array", "optionsArray": ["false","true"], "title": "Overwrite With Best Model", "description": "If enabled, override the final model with the best model found during training.", "datatypes":["boolean"]},
    {"name": "useAllFactorLevels", "value":"true", "widget": "textfield", "title": "Use All Factor Levels", "description": "Use all factor levels of categorical variables. Otherwise, the first factor level is omitted (without loss of accuracy). Useful for variable importances and auto-enabled for autoencoder.", "datatypes":["boolean"]},
    {"name": "diagnostics", "value":"true", "widget": "array", "optionsArray": ["false","true"], "title": "Diagnostics", "description": "Enable diagnostics for hidden layers.", "datatypes":["boolean"]},
    {"name": "calculateFeatureImportances", "value":"true", "widget": "array", "optionsArray": ["false","true"], "title": "Calculate Feature Importances", "description": "Compute variable importances for input features (Gedeon method) - can be slow for large networks.", "datatypes":["boolean"]},
    {"name": "fastMode", "value":"true", "widget": "array", "optionsArray": ["false","true"], "title": "Fast Mode", "description": "SEnable fast mode (minor approximation in back-propagation).", "datatypes":["boolean"]},
    {"name": "forceLoadBalance", "value":"true", "widget": "array", "optionsArray": ["false","true"], "title": "Force Load Balance", "description": "Force extra load balancing to increase training speed for small datasets (to keep all cores busy).", "datatypes":["boolean"]},
    {"name": "replicateTrainingData", "value":"true", "widget": "array", "optionsArray": ["false","true"], "title": "Replicate Training Data", "description": "Replicate the entire training dataset onto every node for faster training on small datasets.", "datatypes":["boolean"]},
    {"name": "singleNodeMode", "value":"false", "widget": "array", "title": "Single Node Mode", "optionsArray": ["false","true"], "description": "Run on a single node for fine-tuning of model parameters.", "datatypes":["boolean"]},
    {"name": "shuffleTrainingData", "value":"false", "widget": "array", "title": "Shuffle Training Data", "optionsArray": ["false","true"], "description": "Enable shuffling of training data (recommended if training data is replicated and train_samples_per_iteration is close to #nodes x #rows, of if using balance_classes).", "datatypes":["boolean"]},
    {"name": "missingValuesHandling", "value":"MeanImputation", "widget": "array", "title": "Missing Values Handling", "optionsArray": ["MeanImputation","Skip"] ,"description": "Handling of missing values. Either MeanImputation or Skip."},
    {"name": "sparse", "value":"false", "widget": "array", "title": "Sparse", "optionsArray": ["false","true"], "description": "Sparse data handling (more efficient for data with lots of 0 values).", "datatypes":["boolean"]},
    {"name": "averageActivation", "value":"0.0", "widget": "textfield", "title": "Average Activation", "description": "Average activation for sparse auto-encoder. #Experimental.", "datatypes":["double"]},
    {"name": "sparsityBeta", "value":"0.0", "widget": "textfield", "title": "Sparsity Beta", "description": "Sparsity regularization. #Experimental.", "datatypes":["double"]},
    {"name": "maxCategoricalFeatures", "value":"2147483647", "widget": "textfield", "title": "Max Categorical Features", "description": "Max. number of categorical features, enforced via hashing. #Experimental.", "datatypes":["integer"]},
    {"name": "reproducible", "value":"false", "widget": "array", "title": "Reproducible", "optionsArray": ["false","true"], "description": "Force reproducibility on small data (will be slow - only uses 1 thread).", "datatypes":["boolean"]},
    {"name": "exportWeightsAndBiases", "value":"false", "widget": "array", "title": "Export Weights And Biases", "optionsArray": ["false","true"], "description": "Whether to export Neural Network weights and biases to H2O Frames.", "datatypes":["boolean"]},
    {"name": "miniBatchSize", "value":"1", "widget": "textfield", "title": "Mini Batch Size", "description": "SMini-batch size (smaller leads to better fit, larger can speed up and generalize better).", "datatypes":["integer"]},
    {"name": "elasticAveraging", "value":"false", "widget": "array", "title": "Elastic Averaging", "optionsArray": ["false","true"], "description": "Elastic averaging between compute nodes can improve distributed model convergence. #Experimental.", "datatypes":["boolean"]},
    {"name": "elasticAveragingMovingRate", "value":"0.9", "widget": "textfield", "title": "Elastic Averaging Moving Rate", "description": "Elastic averaging moving rate (only if elastic averaging is enabled).", "datatypes":["double"]},
    {"name": "elasticAveragingRegularization", "value":"0.001", "widget": "textfield", "title": "Elastic Averaging Regularization", "description": "Elastic averaging regularization strength (only if elastic averaging is enabled).", "datatypes":["double"]},
    {"name": "keepCrossValidationModels", "value":"true", "widget": "array","optionsArray": ["false","true"], "title": "Keep Cross Validation Models", "description": "Whether to keep the cross-validated models. Keeping cross-validation models may consume significantly more memory in the H2O cluster."},
    {"name": "keepCrossValidationPredictions", "value":"false", "widget": "array","optionsArray": ["false","true"], "title": "Keep Cross Validation Predictions", "description": "Whether to keep the predictions of the cross-validation predictions. This needs to be set to TRUE if running the same AutoML object for repeated runs because CV predictions are required to build additional Stacked Ensemble models in AutoML."},
    {"name": "keepCrossValidationFoldAssignment", "value":"false", "widget": "array","optionsArray": ["false","true"], "title": "Keep Cross Validation Fold Assignment", "description": "Whether to keep cross-validation assignments."},
    {"name": "distribution", "value":"AUTO", "widget": "array", "title": "Distribution", "optionsArray": ["AUTO", "bernoulli", "quasibinomial", "modified_huber", "multinomial", "ordinal", "gaussian", "poisson", "gamma", "tweedie", "huber", "laplace", "quantile", "fractionalbinomial", "negativebinomial", "custom"], "description": "Distribution function.)" ,"datatypes":["string"]},
    {"name": "tweediePower", "value":"1.5", "widget": "textfield", "title": "Tweedie Power", "description": "Tweedie power for Tweedie regression, must be between 1 and 2.", "datatypes":["double"]},
    {"name": "quantileAlpha", "value":"0.5", "widget": "textfield", "title": "Quantile Alhpa", "description": "Desired quantile for Quantile regression, must be between 0 and 1.", "datatypes":["double"]},
    {"name": "huberAlpha", "value":"0.9", "widget": "textfield", "title": "Huber Alpha", "description": "Desired quantile for Huber/M-regression (threshold between quadratic and linear loss, must be between 0 and 1).", "datatypes":["double"]},
    {"name": "weightCol", "value":"", "widget": "variable", "title": "Weight Column", "description": "Column with observation weights. Giving some observation a weight of zero is equivalent to excluding it from the dataset; giving an observation a relative weight of 2 is equivalent to repeating that row twice. Negative weights are not allowed. Note: Weights are per-row observation weights and do not increase the size of the data frame. This is typically the number of times a row is repeated, but non-integer values are supported as well. During training, rows with higher weights matter more, due to the larger loss function pre-factor. If you set weight = 0 for a row, the returned prediction frame at that row is zero and this is incorrect. To get an accurate prediction, remove all rows with weight == 0."},
    {"name": "offsetCol", "value":"", "widget": "variable", "title": "Offset Column", "description": "Offset column. This will be added to the combination of columns before applying the link function."},
    {"name": "foldCol", "value":"", "widget": "variable", "title": "Fold Column", "description": "Column with cross-validation fold index assignment per observation."},
    {"name": "foldAssignment", "value":"AUTO", "widget": "array", "title": "Fold Assignment", "optionsArray": ["AUTO","Random", "Modulo", "Stratified"], "description": "Cross-validation fold assignment scheme, if fold_column is not specified. The 'Stratified' option will stratify the folds based on the response variable, for classification problems." ,"datatypes":["string"]},
    {"name": "aucType", "value":"AUTO", "widget": "array","optionsArray": ["AUTO","NONE", "MACRO_OVR", "WEIGHTED_OVR", "MACRO_OVO", "WEIGHTED_OVO"], "title": "AUC Type", "description": "Set default multinomial AUC type."},

    {"name": "confusionMatrix", "value":"", "widget": "tab", "title": "Confusion Matrix"},
    {"name": "output_confusion_matrix_chart", "value":"false", "widget": "array", "title": "Output Confusion Matrix Chart", "optionsArray": ["false","true"], "description": "whether to display confusion matrix chart." ,"datatypes":["boolean"]},
    {"name": "cm_chart_title", "value":"Confusion Matrix Chart", "widget": "textfield", "title": "Confusion Matrix Chart Title", "description": "Title name to display in Confusion Matrix Chart"},
    {"name": "cm_chart_description", "value":"Visual Representation of Predicted vs. Actual Classes", "widget": "textfield", "title": "Confusion Matrix Chart Description", "description": " Description to display in Confusion Matrix CHart"},
    {"name": "confusionMatrixTargetLegend", "value":"Target", "widget": "textfield", "title": "Confusion Matrix Target Legend", "description": "Legend name to display for Target in Confusion Matrix"},
    {"name": "confusionMatrixPredictedLabelLegend", "value":"PredictedLabel", "widget": "textfield", "title": "Confusion Matrix PredictedLabel Legend", "description": "Legend name to display for Predicted Label in Confusion Matrix"},

    {"name": "ROC Curve", "value":"", "widget": "tab", "title": "ROC Curve"},
    {"name": "output_roc_curve", "value":"false", "widget": "array", "title": "Output ROC Curve", "optionsArray": ["false","true"], "description": "Whether to display confusion matrix chart." ,"datatypes":["boolean"]},
    {"name": "roc_title", "value":"ROC Chart", "widget": "textfield", "title": "ROC Curve Chart Title", "description": "Title name to display in ROC Curve Chart"},
    {"name": "roc_description", "value":"Receiver operating characteristic (ROC) curve", "widget": "textfield", "title": "ROC Curve Chart Description", "description": "Add Description for ROC Curve Chart"},
    {"name": "xlabel", "value":"False Positive Rate (specificity)", "widget": "textfield", "title": "X Label", "description": "X label"},
    {"name": "ylabel", "value":"True Positive Rate (sensitivity)", "widget": "textfield", "title": "Y Label", "description": "Y Label"},

    {"name": "Grid Search", "value":"", "widget": "tab", "title": "Grid Search"},
    {"name": "paramKeys", "value":"[]", "widget": "key_array", "title": "Param Name", "description": "Param Names. eg: l1 ,hidden"},
    {"name": "paramValues", "value":"[]", "widget": "value_array", "title": "Param Value", "description": "Enter comma separated values.eg: 0, 1e-5, eg: 50,50;100,100"},
    {"name":"gridStrategy","value":"Cartesian","widget":"array","optionsArray":["Cartesian","RandomDiscrete"],"title":"Grid Search Strategy","description":"Strategy to use for model hyperparameter search. Cartesian does exhaustive search; RandomDiscrete searches randomly within given time or model limits.","datatypes":["string"]},
    {"name":"gridMaxModels","value":"0","widget":"textfield","title":"Grid Max Models","description":"Maximum number of models to build in the grid search (0 for unlimited).","datatypes":["integer"]},
    {"name":"gridMaxRuntimeSecs","value":"0","widget":"textfield","title":"Grid Max Runtime Seconds","description":"Maximum runtime in seconds for the grid search (0 for unlimited).","datatypes":["double"]},
    {"name":"gridStoppingRounds","value":"3","widget":"textfield","title":"Grid Stopping Rounds","description":"Early stopping based on convergence of the metric during grid search (0 to disable).","datatypes":["integer"]},
    {"name":"gridStoppingTolerance","value":"0.001","widget":"textfield","title":"Grid Stopping Tolerance","description":"Tolerance for metric-based stopping criterion during grid search.","datatypes":["double"]},
    {"name":"gridStoppingMetric","value":"AUTO","widget":"array","optionsArray":["AUTO","deviance","logloss","MSE","RMSE","MAE","RMSLE","AUC","AUCPR","lift_top_group","misclassification","mean_per_class_error","anomaly_score","custom","custom_increasing"],"title":"Grid Stopping Metric","description":"Metric to use for early stopping during grid search (AUTO: logloss for classification, deviance for regression).","datatypes":["string"]},
    {"name":"gridParallelism","value":"2","widget":"textfield","title":"Grid Parallelism","description":"Level of parallelism to use when building models in the grid.","datatypes":["integer"]},
    {"name":"gridSelectBestModelBy","value":"AUTO","widget":"array","optionsArray":["AUTO","logloss","MSE","RMSE","MAE","RMSLE","AUC","AUCPR"],"title":"Grid Select Best Model By","description":"Metric used to select the best model from the grid.","datatypes":["string"]}

  ]
}

start-details:

H2O’s Deep Learning is based on a multi-layer feedforward artificial neural network that is trained with stochastic gradient descent using back-propagation. The network can contain a large number of hidden layers consisting of neurons with tanh, rectifier, and maxout activation functions.

More details are available at : http://docs.h2o.ai/h2o/latest-stable/h2o-docs/data-science/deep-learning.html

end-details:

