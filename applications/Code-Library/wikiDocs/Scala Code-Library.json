{
  "id": 2008,
  "uuid": "1cf836fe-c88e-4a90-af44-576d24aad67d",
  "name": "Scala Code-Library",
  "category": "",
  "projectId": 1553,
  "content": "<h2><strong style=\"color: rgb(0, 71, 178);\">Scala Code-Library</strong></h2><p><br></p><p>Input Data Strecture is :-</p><ol><li><strong>id</strong>: Identifier for each property or entry.</li><li><strong>price</strong>: Price of the property.</li><li><strong>lotsize</strong>: Size of the lot on which the property is built, likely in square feet or meters.</li><li><strong>bedrooms</strong>: Number of bedrooms in the property.</li><li><strong>bathrms</strong>: Number of bathrooms in the property.</li><li><strong>stories</strong>: Number of stories (floors) in the property.</li><li><strong>driveway</strong>: Whether the property has a driveway (usually a binary value like 0 for No, 1 for Yes).</li><li><strong>recroom</strong>: Whether the property has a recreation room (0 for No, 1 for Yes).</li><li><strong>fullbase</strong>: Whether the property has a full basement (0 for No, 1 for Yes).</li><li><strong>gashw</strong>: Whether the property has gas hot water (0 for No, 1 for Yes).</li><li><strong>airco</strong>: Whether the property has air conditioning (0 for No, 1 for Yes).</li><li><strong>garagepl</strong>: Number of garage places (possibly a count of parking spaces).</li><li><strong>prefarea</strong>: Whether the property is in a preferred area (0 for No, 1 for Yes).</li></ol><p><br></p><p><br></p><p><code><strong>Scala Code-Library 1-</strong></code></p><p><code>inDF.groupBy(\"bathrms\").count()</code> groups the data in <code>inDF</code> by the number of bathrooms (<code>bathrms</code>) and counts the occurrences of each unique bathroom count.</p><p><code>outDF.registerTempTable(\"outDF\")</code> registers <code>outDF</code> (the grouped DataFrame) as a temporary table called <code>\"outDF\"</code>.</p><p><strong>Output column we are getting from Scala Code-Library Node 1:</strong></p><p><strong>bathrms</strong>: Number of bathrooms in the property</p><p><strong>Counts: Count of each type of bathrooms</strong></p><p><br></p><p><code><strong>Scala Code-Library 2-</strong></code></p><p><strong>This Scala code finds the lowest-priced property for each unique number of bedrooms from the dataset. Here?s how it works step-by-step in the context of your listed columns:</strong></p><ol><li><strong>Import Statements</strong>:</li></ol><pre class=\"ql-syntax\" spellcheck=\"false\">import org.apache.spark.sql.expressions.Window\nimport org.apache.spark.sql._\nimport org.apache.spark.sql.functions._\n</pre><ol><li>These imports bring in necessary Spark SQL classes and functions:</li></ol><ul><li class=\"ql-indent-1\"><code>Window</code> for defining window specifications,</li><li class=\"ql-indent-1\"><code>Spark SQL</code> functions for column operations like ranking and filtering.</li></ul><ol><li><strong>Defining a Window Specification</strong>:</li></ol><pre class=\"ql-syntax\" spellcheck=\"false\">val window = Window.partitionBy(\"bedrooms\").orderBy(\"price\")\n</pre><ol><li>Here, a window specification called <code>window</code> is created:</li></ol><ul><li class=\"ql-indent-1\"><code>partitionBy(\"bedrooms\")</code>: Divides the data into partitions based on the <code>bedrooms</code> column, so each partition contains properties with the same number of bedrooms.</li><li class=\"ql-indent-1\"><code>orderBy(\"price\")</code>: Orders each partition by the <code>price</code> column in ascending order. This will allow us to rank properties within each bedroom group by price, with the lowest price ranked first.</li></ul><ol><li><strong>Adding a Rank Column</strong>:</li></ol><pre class=\"ql-syntax\" spellcheck=\"false\">val rankDF = inDF.withColumn(\"rank\", rank() over window)\n</pre><ol><li>This line creates a new DataFrame <code>rankDF</code> by adding a <code>rank</code> column to <code>inDF</code>:</li></ol><ul><li class=\"ql-indent-1\"><code>rank() over window</code>: The <code>rank</code> function assigns a rank to each property within its bedroom partition, ordering by price. The property with the lowest price in each bedroom group gets a <code>rank</code> of 1.</li></ul><ol><li><strong>Filtering for the Lowest Price in Each Bedroom Group</strong>:</li></ol><pre class=\"ql-syntax\" spellcheck=\"false\">val lowestPriceDF = rankDF.filter(col(\"rank\") === 1)\n</pre><ol><li>Here, <code>rankDF</code> is filtered to include only properties with <code>rank</code> equal to 1 in each bedroom group:</li></ol><ul><li class=\"ql-indent-1\">This step effectively keeps only the property with the lowest price for each unique number of bedrooms.</li></ul><ol><li><strong>Removing the Rank Column</strong>:</li></ol><pre class=\"ql-syntax\" spellcheck=\"false\">val outDF = lowestPriceDF.drop(col(\"rank\"))\n</pre><ol><li>The rank column is now dropped from <code>lowestPriceDF</code>, creating <code>outDF</code>, which contains only the original columns (<code>id</code>, <code>price</code>, <code>lotsize</code>, etc.) and the lowest-priced property for each bedroom count.</li><li><strong>Registering </strong><code>outDF</code><strong> as a Temporary Table</strong>:</li></ol><pre class=\"ql-syntax\" spellcheck=\"false\">outDF.registerTempTable(\"outDF\")\n</pre><ol><li>This registers <code>outDF</code> as a temporary table named <code>\"outDF\"</code></li></ol><p><code><strong>Output column we are getting from Scala Code-Library Node 2:</strong></code></p><ul><li><code>id</code><strong>: Unique identifier for each property.</strong></li><li><code>price</code>: Price of the property (used for ranking to find the lowest price in each bedroom category).</li><li><code>lotsize</code>: Size of the lot the property is built on.</li><li><code>bedrooms</code>: Number of bedrooms (used for partitioning in the window specification).</li><li><code>bathrms</code>: Number of bathrooms in the property.</li><li><code>stories</code>: Number of stories (floors).</li><li><code>driveway</code>: Indicates if there?s a driveway (binary indicator).</li><li><code>recroom</code>: Indicates if there?s a recreation room (binary indicator).</li><li><code>fullbase</code>: Indicates if there?s a full basement (binary indicator).</li><li><code>gashw</code>: Indicates if there?s gas hot water (binary indicator).</li><li><code>airco</code>: Indicates if the property has air conditioning (binary indicator).</li><li><code>garagepl</code>: Number of garage places.</li><li><code>prefarea</code>: Indicates if the property is in a preferred area (binary indicator).</li></ul><p><br></p>",
  "icon": "{\"type\":\"svg\",\"icon\":\"images/createApplications.svg\"}",
  "description": "",
  "syncedWithGithub": false,
  "createdBy": "admin",
  "dateCreated": "May 5, 2025, 12:53:40 PM",
  "dateLastUpdated": "May 5, 2025, 12:53:40 PM"
}